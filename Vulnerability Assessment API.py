import requests
import pandas as pd
import sqlalchemy as sa
import json

# Replace these variables with your actual values
cbc_hostname = "https://your-hostname.com"
org_key = "your_org_key"
api_secret = "your_api_secret"
api_id = "your_api_id"

# Correct deployment type (e.g., "ENDPOINT" or "WORKLOAD")
#deployment_type = "ENDPOINT, WORKLOAD"  # Correct the value to match acceptable values
severity = "ALL", "CRITICAL", "IMPORTANT", "MODERATE", "LOW"  # Optional, e.g., "CRITICAL", "IMPORTANT", "MODERATE", "LOW"

# Construct the search endpoint URL with optional parameters
search_url = f"{cbc_hostname}/vulnerability/assessment/api/v1/orgs/{org_key}/vulnerabilities/summary?Severity={severity}"

# Set up the headers
headers = {
    "X-AUTH-TOKEN": f"{api_secret}/{api_id}",
    "Content-Type": "application/json"
}

# Debugging info
print(f"Requesting URL: {search_url}")

# Make the API call using GET method
response = requests.get(search_url, headers=headers)

if response.status_code == 200:
    try:
        response_data = response.json()
        severity_summary = response_data.get("severity_summary", {})
        
        if severity_summary:
            data_to_save = []
            for severity_level, details in severity_summary.items():
                for os, os_details in details["asset_summary"].items():
                    os_details["severity_level"] = severity_level
                    os_details["os"] = os
                    data_to_save.append(os_details)
                    
            vul_assess_df = pd.DataFrame(data_to_save)
        else:
            print(f"Status Code: {response.status_code}")
            print("No vulnerability data available.")
        
    except requests.exceptions.JSONDecodeError:
        print("Error decoding JSON.")
else:
    print(f"Error: {response.status_code} - {response.text}")

# Save to Excel
#vul_assess_df.to_excel("C:/path/to/your/directory/Vulnerability_Assessment_Data.xlsx", index=False)
#print("Data saved to Excel.")

def load_to_sql(df, table_name):
    MAX_VARCHAR_LENGTH = 255

    # Convert any dictionary or list columns to JSON strings
    for col in df.columns:
        if df[col].dtype == 'object':
            if df[col].apply(lambda x: isinstance(x, (dict, list))).any():
                df[col] = df[col].apply(lambda x: json.dumps(x) if isinstance(x, (dict, list)) else x)

    # Truncate string columns to the max length
    for col in df.select_dtypes(include=['object']).columns:
        df[col] = df[col].apply(lambda x: x[:MAX_VARCHAR_LENGTH] if isinstance(x, str) else x)

    # Define data types for each column
    dtype = {col: sa.types.String(length=MAX_VARCHAR_LENGTH) for col in df.columns}

    connection_string = (
        "Driver={ODBC Driver 17 for SQL Server};"
        "Server=your_server;"
        "Database=your_database;"
        "Integrated Security=SSPI;"
        "port=1433;"
        "Trusted_Connection=yes;"
    )

    connection_url = sa.engine.URL.create("mssql+pyodbc", query=dict(odbc_connect=connection_string))
    engine = sa.create_engine(connection_url, fast_executemany=True)

    try:
        df.to_sql(table_name, engine, if_exists="replace", index=False, dtype=dtype, schema="your_schema")
        print("Data loaded to SQL successfully.")
    except Exception as e:
        print(f"Error loading data to SQL: {e}")

# Load data to SQL
if not vul_assess_df.empty:
    load_to_sql(vul_assess_df, "Vulnerability_Assessment")
